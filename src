#pragma region VEXcode Generated Robot Configuration
// Make sure all required headers are included.
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <math.h>
#include <string.h>


#include "vex.h"

using namespace vex;

// Brain should be defined by default
brain Brain;


// START IQ MACROS
#define waitUntil(condition) \
do { \
wait(5, msec); \
} while (!(condition))

#define repeat(iterations) \
for (int iterator = 0; iterator < iterations; iterator++)
// END IQ MACROS


// Robot configuration code.
inertial BrainInertial = inertial();
motor dMotor = motor(PORT3, true);
sonar dL = sonar(PORT12);
sonar dR = sonar(PORT7);
/*vex-vision-config:begin*/
vision::signature sV__G = vision::signature (1, -7761, -5515, -6638,-5041, -3343, -4192,1.4, 0);
vision::signature sV__R = vision::signature (2, 7835, 9063, 8448,235, 937, 586,3, 0);
vision::signature sV__B = vision::signature (3, 0, 0, 0,0, 0, 0,3, 0);
vision sV = vision (PORT9, 65, sV__G, sV__R, sV__B);
/*vex-vision-config:end*/
distance dF = distance(PORT4);
motor LeftDriveSmart = motor(PORT1, 1, false);
motor RightDriveSmart = motor(PORT2, 1, true);
drivetrain Drivetrain = drivetrain(LeftDriveSmart, RightDriveSmart, 250, 173, 76, mm, 1);
touchled lCorner = touchled(PORT6);
#pragma endregion VEXcode Generated Robot Configuration

// Include the IQ Library
#include "vex.h"
#include "math.h"

// Allows for easier use of the VEX Library
using namespace vex;


char side = ' ';
const int cd = 700; //corner distance
const int dif = 300; //difference to reduce speed in corners
double l, r, f;
double bl, br;
bool ob = false; //obstacles true or false
int corners = 0;
int g = 0; //degrees to quorridors.

class mark
{
int x, y, w, h, s;
bool valid = false;
char c = ' ';
public:
mark(int ex, int ey)
{
x = ex;
y = ey;
s = 0;
}

mark()
{
x = 0;
y = 0;
s = 0;
}

void set (int ex, int ey, int ew, int eh, char ecolor)
{
x = ex;
y = ey;
w = ew;
h = eh;
s = h * w;
c = ecolor;
valid = true;

}

int size ()
{
return s;
}

char color()
{
return c;
}

void navigate()
{
dMotor.spinToPosition((x > 160 ? -60 : 60) , degrees);
Drivetrain.setDriveVelocity(15, percent);
Drivetrain.drive(forward);
while (f > 600)
wait(0.1, seconds);
dMotor.spinToPosition(0 , degrees);
while (f < 200)
wait (0.1, seconds);
Drivetrain.stop();
wait(1000, seconds);
if (!valid)
return;
}
};


mark get_objects()
{
mark obj1 (0, 0);
mark obj2 (0, 0);
sV.takeSnapshot(sV__G);
//green
if (sV.objectCount > 0) //there are green elements
{
obj1.set( sV.largestObject.centerX, sV.largestObject.centerY, sV.largestObject.width, sV.largestObject.height, 'g');
}

//red
sV.takeSnapshot(sV__R);
if (sV.objectCount > 0) //there are green elements
{
obj2.set( sV.largestObject.centerX, sV.largestObject.centerY, sV.largestObject.width, sV.largestObject.height, 'r');
}

return (obj1.size() > obj2.size()? obj1: obj2);
}

bool obstacles_set ()
{
sV.takeSnapshot(sV__G);
wait(0.1, seconds);
if (sV.objectCount > 0) //there are green elements
{
Brain.Screen.print("Obstacles : Green");
return true;
}

sV.takeSnapshot(sV__R);
wait(0.1, seconds);
if (sV.objectCount > 0) //there are red elements
{
Brain.Screen.print("Obstacles : Red");
return true;
}
return false;
}

int corner()
{
lCorner.setColor(green);
corners++;
Brain.Screen.print (" %d ", corners);
dMotor.spinToPosition ((side == 'l'? -60 : 60), degrees);
Drivetrain.drive(forward);
wait(0.2, seconds);
if ((g == 0) && (side == 'l'))
g = 360;
else if ((g == 360) && (side == 'r'))
g = 0;
while (abs (g - BrainInertial.heading(degrees)) < (corners == 1? 63 : 60))
continue;
// Drivetrain.stop();
dMotor.spinToPosition(0, degrees);
Drivetrain.setTurnVelocity(100, percent);

lCorner.setColor(red);
return 0;
}
// "when started" hat block
int fw () {
if ((corners <= 1) && (ob == false)) //validate round type
ob = obstacles_set();

if (ob) //obstacles rounds
{
mark n_mark = get_objects();
n_mark.navigate();
}
else //clean rounds
{
Drivetrain.drive(forward);
wait (0.15, seconds);

while (dF.objectDistance(mm) > (cd + (corners < 1? 0: dif)))
{
int temp_d = BrainInertial.heading(degrees);
if (true) //corners > 1)
{
if ((side == 'l') && (g == 0))
{
temp_d = (temp_d > 270 ? temp_d = temp_d - 360 : temp_d);
}
else if ((side == 'r') && (g == 360))
{
temp_d = (temp_d < 90 ? temp_d = temp_d + 360: temp_d);
}
}

if ((temp_d > (g + 1))&&(corners >= 1))
{
//Brain.playNote(4,5,250);
lCorner.setColor(yellow);
dMotor.spinToPosition(-15, degrees);
dMotor.spinToPosition(0, degrees);
}
else if ((temp_d < (g - 1) ))//&&(corners >= 1))
{
//Brain.playNote(4,1,250);
lCorner.setColor(blue);
dMotor.spinToPosition(15, degrees);
dMotor.spinToPosition(0, degrees);
}
}
}
if (corners < 1 )
{
Drivetrain.stop();
}

if (side == ' ')
{
if (dL.distance(mm)< 800) //|| (dR.distance(mm) > 800))
side = 'r';
else
side = 'l';
}

//next side degree set.
corner();
g += (side == 'l'? -90: 90);
g = (g >= 450? 90: (g <= -90? 270 : g));
if ((corners <= 1) && (ob == false))
ob = obstacles_set();
return 0;
}

void distance_monitor()
{
while (true)
{


l = dL.distance(mm);
r = dR.distance(mm);
f = dF.objectDistance(mm);
/*
Brain.Screen.clearScreen();
Brain.Screen.clearLine(1);
Brain.Screen.clearLine(2);
Brain.Screen.clearLine(3);
Brain.Screen.print("l %2.0f", l);
Brain.Screen.print("r %2.0f", r);
Brain.Screen.print("f %2.0f ", f);
Brain.Screen.print("\n");
Brain.Screen.newLine();
*/
/*Brain.Screen.print(" %2.0f ", BrainInertial.orientation(yaw, degrees));
Brain.Screen.print(" %2.0f ", BrainInertial.orientation(pitch, degrees));
Brain.Screen.print(" %2.0f ", BrainInertial.orientation(roll, degrees));*/
//
}
}



int main() {
Drivetrain.setTurnVelocity(100,percent);
dMotor.setVelocity(100, percent);
dMotor.setStopping(hold);
thread myThread = thread(distance_monitor);

while (corners <= 11)
fw();
Drivetrain.driveFor(forward, 3, inches, true);
Drivetrain.stop();


}
